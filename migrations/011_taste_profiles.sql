-- Migration: Taste Profile ML Engine (Phase 2)
-- Creates tables and functions for multi-dimensional taste profiling
-- Run this in your Supabase SQL Editor

-- ============================================
-- 1. TASTE PROFILES
-- ============================================
CREATE TABLE IF NOT EXISTS taste_profiles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE NOT NULL,

  -- Food Dimension (384-dim embeddings stored as vector)
  -- Note: Requires pgvector extension - run: CREATE EXTENSION IF NOT EXISTS vector;
  food_embedding vector(384),
  cuisine_preferences JSONB, -- { "italian": 0.8, "japanese": 0.9, ... }
  michelin_affinity FLOAT CHECK (michelin_affinity >= 0.0 AND michelin_affinity <= 1.0),
  street_food_affinity FLOAT CHECK (street_food_affinity >= 0.0 AND street_food_affinity <= 1.0),
  fine_dining_affinity FLOAT CHECK (fine_dining_affinity >= 0.0 AND fine_dining_affinity <= 1.0),
  experimental_score FLOAT CHECK (experimental_score >= 0.0 AND experimental_score <= 1.0), -- Traditional vs experimental

  -- Ambiance Dimension
  ambiance_embedding vector(384),
  crowd_tolerance FLOAT CHECK (crowd_tolerance >= 0.0 AND crowd_tolerance <= 1.0), -- Busy vs quiet
  formality_preference FLOAT CHECK (formality_preference >= 0.0 AND formality_preference <= 1.0), -- Casual vs formal
  indoor_outdoor_ratio FLOAT CHECK (indoor_outdoor_ratio >= 0.0 AND indoor_outdoor_ratio <= 1.0), -- 0 = indoor, 1 = outdoor
  modern_vs_historic FLOAT CHECK (modern_vs_historic >= 0.0 AND modern_vs_historic <= 1.0),

  -- Price Dimension
  avg_price_point FLOAT CHECK (avg_price_point >= 1.0 AND avg_price_point <= 4.0), -- 1-4 ($ to $$$$)
  price_variance FLOAT, -- Standard deviation of price preferences
  value_sensitivity FLOAT CHECK (value_sensitivity >= 0.0 AND value_sensitivity <= 1.0), -- Price/quality importance
  splurge_frequency FLOAT CHECK (splurge_frequency >= 0.0 AND splurge_frequency <= 1.0), -- Occasional luxury

  -- Adventure Dimension
  novelty_seeking FLOAT CHECK (novelty_seeking >= 0.0 AND novelty_seeking <= 1.0), -- New vs familiar
  tourist_vs_local FLOAT CHECK (tourist_vs_local >= -1.0 AND tourist_vs_local <= 1.0), -- -1 = tourist, 1 = local
  spontaneity_score FLOAT CHECK (spontaneity_score >= 0.0 AND spontaneity_score <= 1.0),
  risk_tolerance FLOAT CHECK (risk_tolerance >= 0.0 AND risk_tolerance <= 1.0), -- Experimental choices

  -- Culture Dimension
  culture_embedding vector(384),
  art_affinity FLOAT CHECK (art_affinity >= 0.0 AND art_affinity <= 1.0),
  history_affinity FLOAT CHECK (history_affinity >= 0.0 AND history_affinity <= 1.0),
  architecture_affinity FLOAT CHECK (architecture_affinity >= 0.0 AND architecture_affinity <= 1.0),

  -- Meta
  confidence_score FLOAT CHECK (confidence_score >= 0.0 AND confidence_score <= 1.0), -- Based on interaction count
  interaction_count INT DEFAULT 0,
  version INT DEFAULT 1, -- Incremented when profile is regenerated

  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_taste_profiles_user_id ON taste_profiles(user_id);
CREATE INDEX IF NOT EXISTS idx_taste_profiles_confidence ON taste_profiles(confidence_score DESC);

-- Vector similarity indexes (requires pgvector extension)
CREATE INDEX IF NOT EXISTS idx_taste_profiles_food_embedding
  ON taste_profiles USING ivfflat (food_embedding vector_cosine_ops);

CREATE INDEX IF NOT EXISTS idx_taste_profiles_ambiance_embedding
  ON taste_profiles USING ivfflat (ambiance_embedding vector_cosine_ops);

CREATE INDEX IF NOT EXISTS idx_taste_profiles_culture_embedding
  ON taste_profiles USING ivfflat (culture_embedding vector_cosine_ops);

-- ============================================
-- 2. TASTE EVOLUTION TRACKING
-- ============================================
CREATE TABLE IF NOT EXISTS taste_evolution (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,

  snapshot_date TIMESTAMP WITH TIME ZONE NOT NULL,
  taste_snapshot JSONB NOT NULL, -- Full TasteProfile as JSON

  -- Change metrics (deltas from previous snapshot)
  delta_novelty_seeking FLOAT,
  delta_price_point FLOAT,
  delta_formality FLOAT,
  delta_experimental FLOAT,

  -- Euclidean distance from previous snapshot
  overall_change_magnitude FLOAT,

  -- Insights (generated by ML)
  insights JSONB, -- { "shifts": ["Now prefers more casual dining"], "stable": ["Still loves Italian"] }

  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_taste_evolution_user_id ON taste_evolution(user_id);
CREATE INDEX IF NOT EXISTS idx_taste_evolution_user_date ON taste_evolution(user_id, snapshot_date DESC);

-- ============================================
-- 3. DESTINATION TASTE PROFILES
-- ============================================
-- Pre-computed taste profiles for destinations
CREATE TABLE IF NOT EXISTS destination_taste_profiles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  destination_id INT REFERENCES destinations(id) ON DELETE CASCADE UNIQUE NOT NULL,

  -- Food characteristics
  food_embedding vector(384),
  cuisine_type TEXT,
  food_quality_score FLOAT CHECK (food_quality_score >= 0.0 AND food_quality_score <= 1.0),
  michelin_status BOOLEAN DEFAULT FALSE,
  experimental_level FLOAT CHECK (experimental_level >= 0.0 AND experimental_level <= 1.0),

  -- Ambiance characteristics
  ambiance_embedding vector(384),
  formality_score FLOAT CHECK (formality_score >= 0.0 AND formality_score <= 1.0),
  crowd_level FLOAT CHECK (crowd_level >= 0.0 AND crowd_level <= 1.0),
  indoor_outdoor TEXT, -- 'indoor', 'outdoor', 'mixed'
  noise_level FLOAT CHECK (noise_level >= 0.0 AND noise_level <= 1.0),

  -- Price
  price_level INT CHECK (price_level >= 1 AND price_level <= 4),
  value_rating FLOAT CHECK (value_rating >= 0.0 AND value_rating <= 1.0), -- Quality per dollar

  -- Novelty
  novelty_score FLOAT CHECK (novelty_score >= 0.0 AND novelty_score <= 1.0), -- How unique/unknown
  tourist_score FLOAT CHECK (tourist_score >= 0.0 AND tourist_score <= 1.0), -- Tourist trap vs local gem

  -- Culture
  culture_embedding vector(384),
  cultural_significance FLOAT CHECK (cultural_significance >= 0.0 AND cultural_significance <= 1.0),
  historic_value FLOAT CHECK (historic_value >= 0.0 AND historic_value <= 1.0),

  -- Metadata
  generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_destination_taste_profiles_destination_id
  ON destination_taste_profiles(destination_id);

-- Vector indexes
CREATE INDEX IF NOT EXISTS idx_destination_taste_profiles_food_embedding
  ON destination_taste_profiles USING ivfflat (food_embedding vector_cosine_ops);

CREATE INDEX IF NOT EXISTS idx_destination_taste_profiles_ambiance_embedding
  ON destination_taste_profiles USING ivfflat (ambiance_embedding vector_cosine_ops);

-- ============================================
-- 4. USER-DESTINATION MATCH SCORES
-- ============================================
-- Cache of calculated match scores
CREATE TABLE IF NOT EXISTS taste_match_scores (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  destination_id INT REFERENCES destinations(id) ON DELETE CASCADE NOT NULL,

  -- Overall match
  overall_score FLOAT CHECK (overall_score >= 0.0 AND overall_score <= 1.0),

  -- Dimension-specific scores
  food_match FLOAT CHECK (food_match >= 0.0 AND food_match <= 1.0),
  ambiance_match FLOAT CHECK (ambiance_match >= 0.0 AND ambiance_match <= 1.0),
  price_match FLOAT CHECK (price_match >= 0.0 AND price_match <= 1.0),
  adventure_match FLOAT CHECK (adventure_match >= 0.0 AND adventure_match <= 1.0),
  culture_match FLOAT CHECK (culture_match >= 0.0 AND culture_match <= 1.0),

  -- Confidence based on user profile confidence
  confidence FLOAT CHECK (confidence >= 0.0 AND confidence <= 1.0),

  -- Cache expiration
  calculated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  expires_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() + INTERVAL '7 days',

  UNIQUE(user_id, destination_id)
);

CREATE INDEX IF NOT EXISTS idx_taste_match_scores_user_id ON taste_match_scores(user_id);
CREATE INDEX IF NOT EXISTS idx_taste_match_scores_overall_score ON taste_match_scores(overall_score DESC);
CREATE INDEX IF NOT EXISTS idx_taste_match_scores_user_score
  ON taste_match_scores(user_id, overall_score DESC);
CREATE INDEX IF NOT EXISTS idx_taste_match_scores_expires_at ON taste_match_scores(expires_at);

-- ============================================
-- 5. TASTE SIGNALS (extracted from interactions)
-- ============================================
CREATE TABLE IF NOT EXISTS taste_signals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,

  -- Aggregated signals (last 30 days)
  cuisine_distribution JSONB, -- { "italian": 15, "japanese": 10, ... }
  price_distribution JSONB, -- { "1": 5, "2": 20, "3": 10, "4": 2 }
  category_distribution JSONB, -- { "restaurant": 40, "bar": 15, ... }

  -- Engagement patterns
  high_engagement_destinations JSONB, -- Array of destination IDs with engagement > 0.7
  avg_engagement_by_cuisine JSONB, -- { "italian": 0.8, "french": 0.6, ... }
  avg_engagement_by_price JSONB, -- { "1": 0.5, "2": 0.7, ... }

  -- Behavioral patterns
  browsing_speed FLOAT, -- Fast vs slow
  exploration_rate FLOAT, -- Many different vs few repeated
  save_rate FLOAT, -- % of viewed items saved
  booking_intent_rate FLOAT, -- % with booking link clicks

  -- Temporal patterns
  preferred_time_of_day TEXT[], -- ['morning', 'evening']
  preferred_day_of_week INT[], -- [0, 1, 5, 6] (Sun, Mon, Fri, Sat)

  -- Recency
  last_calculated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

  UNIQUE(user_id)
);

CREATE INDEX IF NOT EXISTS idx_taste_signals_user_id ON taste_signals(user_id);

-- ============================================
-- 6. ROW LEVEL SECURITY
-- ============================================

ALTER TABLE taste_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE taste_evolution ENABLE ROW LEVEL SECURITY;
ALTER TABLE destination_taste_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE taste_match_scores ENABLE ROW LEVEL SECURITY;
ALTER TABLE taste_signals ENABLE ROW LEVEL SECURITY;

-- Taste Profiles Policies
DROP POLICY IF EXISTS "Users can view own taste profile" ON taste_profiles;
CREATE POLICY "Users can view own taste profile" ON taste_profiles
  FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Service role can manage taste profiles" ON taste_profiles;
CREATE POLICY "Service role can manage taste profiles" ON taste_profiles
  FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');

-- Taste Evolution Policies
DROP POLICY IF EXISTS "Users can view own taste evolution" ON taste_evolution;
CREATE POLICY "Users can view own taste evolution" ON taste_evolution
  FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Service role can manage taste evolution" ON taste_evolution;
CREATE POLICY "Service role can manage taste evolution" ON taste_evolution
  FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');

-- Destination Taste Profiles (publicly readable)
DROP POLICY IF EXISTS "Anyone can view destination taste profiles" ON destination_taste_profiles;
CREATE POLICY "Anyone can view destination taste profiles" ON destination_taste_profiles
  FOR SELECT USING (true);

DROP POLICY IF EXISTS "Service role can manage destination taste profiles" ON destination_taste_profiles;
CREATE POLICY "Service role can manage destination taste profiles" ON destination_taste_profiles
  FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');

-- Match Scores Policies
DROP POLICY IF EXISTS "Users can view own match scores" ON taste_match_scores;
CREATE POLICY "Users can view own match scores" ON taste_match_scores
  FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Service role can manage match scores" ON taste_match_scores;
CREATE POLICY "Service role can manage match scores" ON taste_match_scores
  FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');

-- ============================================
-- 7. HELPER FUNCTIONS
-- ============================================

-- Calculate confidence score based on interaction count
CREATE OR REPLACE FUNCTION calculate_taste_confidence(interaction_count INT)
RETURNS FLOAT AS $$
BEGIN
  -- Logarithmic growth: confidence = log(count + 1) / log(100)
  -- Reaches ~0.5 at 10 interactions, ~0.85 at 50 interactions
  RETURN LEAST(LOG(interaction_count + 1) / LOG(100), 0.95);
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Calculate overall match score from dimension scores
CREATE OR REPLACE FUNCTION calculate_overall_match(
  food_match FLOAT,
  ambiance_match FLOAT,
  price_match FLOAT,
  adventure_match FLOAT,
  culture_match FLOAT
)
RETURNS FLOAT AS $$
BEGIN
  -- Weighted average
  RETURN (
    food_match * 0.35 +
    ambiance_match * 0.25 +
    price_match * 0.20 +
    adventure_match * 0.10 +
    culture_match * 0.10
  );
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Clean up expired match scores
CREATE OR REPLACE FUNCTION cleanup_expired_match_scores()
RETURNS INT AS $$
DECLARE
  deleted_count INT;
BEGIN
  DELETE FROM taste_match_scores
  WHERE expires_at < NOW();

  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- 8. TRIGGERS
-- ============================================

-- Auto-update updated_at timestamp
CREATE OR REPLACE FUNCTION update_taste_profiles_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_taste_profiles_updated_at ON taste_profiles;
CREATE TRIGGER trigger_taste_profiles_updated_at
  BEFORE UPDATE ON taste_profiles
  FOR EACH ROW
  EXECUTE FUNCTION update_taste_profiles_updated_at();

DROP TRIGGER IF EXISTS trigger_destination_taste_profiles_updated_at ON destination_taste_profiles;
CREATE TRIGGER trigger_destination_taste_profiles_updated_at
  BEFORE UPDATE ON destination_taste_profiles
  FOR EACH ROW
  EXECUTE FUNCTION update_taste_profiles_updated_at();

-- ============================================
-- 9. SCHEDULED JOBS (using pg_cron if available)
-- ============================================

-- Clean up expired match scores daily at 3 AM
-- SELECT cron.schedule('cleanup-expired-match-scores', '0 3 * * *', $$SELECT cleanup_expired_match_scores()$$);

-- ============================================
-- 10. COMMENTS
-- ============================================

COMMENT ON TABLE taste_profiles IS 'Multi-dimensional taste profiles for users using ML embeddings';
COMMENT ON TABLE taste_evolution IS 'Historical snapshots of taste profiles to track changes over time';
COMMENT ON TABLE destination_taste_profiles IS 'Pre-computed taste characteristics for destinations';
COMMENT ON TABLE taste_match_scores IS 'Cached user-destination compatibility scores';
COMMENT ON TABLE taste_signals IS 'Aggregated behavioral signals extracted from user interactions';

COMMENT ON COLUMN taste_profiles.food_embedding IS '384-dimensional vector from OpenAI embeddings';
COMMENT ON COLUMN taste_profiles.confidence_score IS 'Profile confidence based on interaction count (0-1)';
COMMENT ON COLUMN taste_profiles.novelty_seeking IS 'Preference for new/unique experiences (0-1)';

COMMENT ON FUNCTION calculate_taste_confidence IS 'Logarithmic confidence calculation from interaction count';
COMMENT ON FUNCTION calculate_overall_match IS 'Weighted average of dimension match scores';
